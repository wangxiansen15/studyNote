# 栈空间和堆空间：数据是如何存储的？

## JavaScript是什么类型的语言

**我们把在使用之前就需要确定其变量数据类型的称为静态语言。相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。**比如JavaScript就是动态语言，因为在声明变量之前不需要确认其数据类型。

虽然C语言是静态语言，但是在C语言中，我们可以把其他类型数据赋予给一个声明好的变量，这段代码也是可以执行的，因为在赋值过程中，C编译器会把int型的变量悄悄转换为bool型的变量，我们通常把这种偷偷转换的操作称为**隐式类型转换**。而**支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言**。在这点上，C和JavaScript都是弱类型语言。

**综上所述，我们知道了JavaScript是一种弱类型的、动态的语言。**

## JavaScript的数据类型

JavaScript是一种弱类型的、动态的语言。

* 弱类型

  意味着你不需要告诉JavaScript引擎这个或那个变量是什么数据类型，JavaScript引擎在运行代码的时候回自己计算出来。

* 动态

  意味着可以使用同一个变量保存不同类型的数据

**JavaScript的数据类型一共有8种，它们分别是：**

* Boolean：只有true和false两个值
* Null：只有一个值null
* Undefined：一个没有被赋值的变量会有一个默认值undefined，变量提升时的默认值也是undefined
* Number：根据ECMAScript标准，JavaScript中只有一种数字类型；基于IEEE754标准的双精度64位二进制格式的值。
* BigInt：JavaScript中的一个新的数字类型，可以用任意精度表示整数。使用BigInt，即使超出Number的安全整数范围限制，也可以安全地存储和操作。
* String：用于表示文本数据。不同于类C语言，JavaScript的字符串是不可更改的。
* Symbol：符号类型是惟一的并且是不可修改的，通常用来做Object的key。
* Object：在JavaScript里，对象可以被看做是一组属性的集合

三点需要注意的

* 使用typeof检测null类型时，返回的是object。这是当初JavaScript语言的一个Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。
* Object比较特殊，它是由上述7种类型组成的一个包含了key-value对的数据类型
* 我们把前面的7种数据类型称为**原始类型**，把最后一个对象类型称为**引用类型**，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。

## 内存空间

在JavaScript的执行过程中，主要有三种类型的内存空间，分别是**代码空间、栈空间和堆空间**。其中代码空间主要是存储可执行代码的。

### 栈空间和堆空间

这里的栈空间就是我们之前反复提及的调用栈，是用来存储执行上下文的。

```js
function foo(){
	var a = "极客时间";
	var b = a;
	var c = {name: "极客时间"};
	var d = c;
}
foo();
```

当执行一段代码时，需要先编译，并创建执行上下文，然后按照顺序执行代码。

当执行到第3行时，变量a和变量b的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以可以认为变量a和变量b的值都是被存放在栈中的。

接下来继续执行第4行代码，由于JavaScript引擎判断右边的值是一个引用类型，这时候处理的情况就不一样了，JavaScript引擎不是直接将该对象存放在变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进c的变量值。

**对象类型时存放在堆空间的，在栈空间中只是保留了对象的引用地址，当JavaScript需要访问该数据的时候，是通过栈中的引用地址来访问的。**

**原始类型的数据都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。**

但为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？

答案是不可以的。这是因为JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大的话，所有数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。

所以**通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过缺点是分配内存和回收内存都占用一定的时间。

在JavaScript中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。

## 再谈闭包

```js
function foo() {
	var myName = "极客时间";
	let test1 = 1;
	const test2 = 2;
	var innerBar = {
		getName:function(){
			console.log(test1);
			return myName;
		},
		setName:function(newName){
			myName = newName;
		}
	}
	return innerBar;
}
var bar = foo();
bar.setName("极客邦");
bar.getName();
console.log(bar.getName());//1 1 "极客邦"
```

当执行这段代码的时候，由于变量myName、test1、test2都是原始类型数据，所以在执行foo函数的时候，它们会被压入到调用栈中；当foo函数执行完成之后，调用栈中foo函数的执行上下文会被销毁，其内部变量myName、test1、test2也应该一同被销毁。

但由于foo函数产生了闭包，所以变量myName和test1并没有被销毁，而是保存在内存中，那么这是如何解释这个现象呢？

要解释这个现象，我们要站在内存模型的角度来分析这段代码的执行流程。

* 当JavaScript引擎执行到foo函数时，首先会编译，并创建一个空执行上下文。
* 在编译过程中，遇到内部函数setName，JavaScript引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了foo函数中的myName变量，由于是内部函数引用了外部函数变量，所以JavaScript判断这是一个闭包，于是在堆空间创建一个“closure(foo)”的对象（这是一个内部对象，JavaScript是无法访问的），用来保存myName变量。
* 接着继续扫描到getName方法时，发现该函数内部还引用变量test1，于是JavaScript引擎又将test1添加到了“closure(foo)”对象中。这时候堆中的"closure(foo)"对象中就包含了myName和test1两个变量了。
* 由于test2并没有被内部函数引用，所以test2依然保存在调用栈中。

![](D:\笔记\img\closure.jpg)

所以当执行到foo函数时，闭包就产生了；当foo函数执行结束之后，返回的getName和setName方法都引用了"closure(foo)"对象，所以即使foo函数推出了，"closure(foo)"依然被其内部的getName和setName方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了"closure(foo)"。

总结：

产生闭包的核心有两步：

* 需要预扫描内部函数
* 把内部函数引用的外部变量保存到堆中

