# 渲染流程

* HTML：HTML的内容是由标签和文本组成。每个标签都有它自己的语意，浏览器会根据标签的语意来正确的展示HTML内容。
* CSS：如果要改变HTML的字体颜色、 大小等消息，就需要用到CSS。CSS又称层叠样式表，是由选择器和属性组成。
* JS：使用它可以使网页的内容‘动’起来。

## 渲染流水线

由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做**渲染流水线**。

按照渲染的时间顺序，流水线可分为如下的几个子阶段：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。

### 构建DOM树

**因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构——DOM树。**

输入HTML ——》HTML解析器进行解析——》输出DOM树

可以在控制台输入document去查看DOM结构，会发现DOM和HTML内容几乎使一模一样的，但是和HTML不同的是，DOM是保存在内存中的树状结构，可以通过JavaScript来查询或修改其内容。

### 样式计算

上一步我们已经生成DOM树了，但是DOM节点的样式我们依然不知道，要让DOM节点拥有正确的样式就需要**样式计算**。

样式计算的目的是为了计算出DOM节点中每个元素的具体样式，一共分为三步来完成。

#### 1.把CSS转换为浏览器能够理解的结构

 CSS样式的来源主要有三种

* 通过link引用的外部CSS文件
* `<style>`标签内的CSS
* 元素的style属性内嵌的CSS

和HTML文件一样，浏览器也是无法直接理解这些纯文本的CSS样式。所以**当渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构——styleSheets。**

可以在控制台输入document.styleSheets去查看该结构

#### 2.转换样式表中的属性值，使其标准化

上一步我们将CSS文本转化为浏览器可以理解的结构了，那么**接下来就要对其进行属性值的标准化操作**。

因为一些数值类型不容易被渲染引擎理解，所以**需要将所有值转换为渲染引擎容易理解的、标准化的计算值**。这个过程就是属性值的标准化。举例：em->px, blue->rgb(0,0,255), font-weight: bold->700

#### 3.计算出DOM树中每个节点的具体样式

**这就涉及到CSS的继承规则和层叠规则了。**

首先是CSS继承。CSS继承就是每个DOM节点都包含有父节点的样式。

**层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在CSS处于核心地位，CSS的全称‘层叠样式表’正是强调了这一点。**

### 布局阶段

现在，我们有了DOM树和DOM树中元素的样式，但这还不足以显示页面，因为我们还不知道DOM元素的几何位置信息。**那么接下来就需要计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。**

Chrome在布局阶段需要完成两个任务：创建布局树和布局计算。

#### 1.创建布局树

DOM树中含有很多不可见元素，比如head标签，还有使用了display：none属性的元素。所以**在显示之前，我们还要额外地构建一棵只包含可见元素布局树。**

构建布局树，浏览器大体完成的工作

* 遍历DOM树中所有可见节点，并把这些节点加到布局中；
* 而不可兼得节点会被布局树忽略掉

#### 2.布局计算

在执行布局操作的时候，会把布局运算的结果重写写回布局树中，所以布局树即使输入内容也是输出内容。

### 分层

因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动、或者使用z-indexing做z轴排序等，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。**

**浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。**

通常情况下，**并不是布局树每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。**

需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？

* 拥有层叠上下文属性的元素会被提升为单独的一层。举例：position:fixed z-index:2 filter:blue(5px) opacity:0.5
* 需要裁剪(clip)的地方也会被创建为图层。出现裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

### 图层绘制

渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多个小的**绘制指令**，然后把这些指令按照顺序组成一个待绘制列表。

### 栅格化操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程。

**通常一个页面可能很大，但用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口**

在有些情况下，有个图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，就会产生太大的开销，而且也没有必要。

基于这个原因，**合成线程会将图层划分为图块**，然后**合成线程会按照视图附近的图块来有限生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**

通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫做快速栅格化，或者GPU栅格化，生成的位图被保存在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作。

### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后在将内存显示在屏幕上。







