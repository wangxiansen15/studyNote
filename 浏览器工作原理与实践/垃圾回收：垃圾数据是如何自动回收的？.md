# 垃圾回收：垃圾数据是如何自动回收的？

有些数据被使用后，就不再需要了，我们把这种数据称为**垃圾数据**。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要**对这些垃圾数据进行回收，以释放有限的内存空间**。

## 不同语言的垃圾回收策略

通常情况下，垃圾数据回收分为**手动回收**和**自动回收**两种策略。

如C/C++就是使用手动回收策略，**何时分配内存、何时销毁内存都是由代码控制的**。

如果有段数据已经不再需要了，但是又没有主动调用free函数来销毁，那么这种情况被称为**内存泄漏**。

另外一种使用的就是自动垃圾回收的策略，如JavaScript、Java、Python等语言，**产生的垃圾数据是由垃圾回收器来释放的**，并不需要手动通过代码来释放。

## 调用栈中的数据是如何回收的

当一个函数执行完毕，函数的执行上下文会用栈中被销毁掉，那么它是怎么被销毁的呢？

当执行一个函数的同时，还有一个**记录当前执行状态的指针（称为ESP）**，指向调用栈中这个函数的执行上下文，表示正在执行当前函数。

接着，当函数执行完成之后，函数执行流程就进入了它的外层函数，那这时候就需要销毁这个函数的执行上下文了。ESP这时候就能帮上忙了，JavaScript会将ESP下移到另一个函数的执行上下文，**这个下移操作就是销毁函数执行上下文的过程**。

因为当ESP向下移动到下个函数的执行上下文中，上面函数的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另一个函数的执行上下文。

所以说，当一个函数执行结束之后，**JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文**。

## 堆中的数据是如何回收的

**要回收堆中的垃圾数据，就要用到JavaScript中的垃圾回收器了**。

### 代际假说

代际假说是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很重要。

**代际假说**有两个特点：

* 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
* 第二个是不死的对象，会活的更久。

其实这两个特点不仅仅适用于JavaScript，同样适用于大多数的动态语言，如Java、Python等。

有了代际假说的基础，我们就可以探讨V8是如何实现垃圾回收的了。

通常，垃圾回收算法有很多，但是并没有哪一种能胜任所有的场景，需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。

所以，在V8中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象。**

对于这两块区域，V8分别使用两个不同的垃圾回收器，以便高效地实施垃圾回收。

* **副垃圾回收器，主要负责新生代的垃圾回收**
* **主垃圾回收器，主要负责老生代的垃圾回收**

### 垃圾回收器的工作流程

**不论什么类型的垃圾回收器，它们都有一套共同的执行流程。**

* 第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
* 第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
* 第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出线内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片。

#### 副垃圾回收器

副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用**Scavenge算法**来处理。所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序的排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种**角色翻转的操作还能让新生代中的这两块区域无线重复使用下去**。

复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以**为了执行效率，一般新生区的空间会被设置得比较小。**

正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript引擎采用了**对象晋级策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区。

### 主垃圾回收器

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一是对象占用空间大，另一个是对象存活时间长。

由于老生区的对象比较大，若要在老生区中使用Scavenge算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，还会浪费一半的空间。因而，主垃圾回收器是采用**标记-清除**的算法进行垃圾回收的。

#### 标记-清除算法

首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。

即当函数执行结束之后，ESP向下移动，指向了另一个函数的执行上下文，这时候如果遍历调用栈，就找不到引用地址的变量，那就意味着这块数据为垃圾数据，被标记为红色。被引用的地址标记为活动对象。

接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程。

#### 标记整理算法

这个标记过程依然与标记-清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 全停顿

V8是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，就需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿**。

因为新生代的空间较小，且存活对象较少，所以全停顿影响不大。

但老生代就不一样，可能占据时间造成卡顿，所以V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记算法**。

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的JavaScript任务中间执行。这样就可以避免卡顿。



