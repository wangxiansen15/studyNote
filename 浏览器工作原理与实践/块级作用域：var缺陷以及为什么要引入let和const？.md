# 块级作用域：var缺陷以及为什么要引入let和const？

## 作用域

**作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。**

ES6之前，ES的作用域只有两种：全局作用域和函数作用域。

* **全局作用域**中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
* **函数作用域**就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

**ES6之前是不支持块级作用域的**

## 变量提升带来的问题

* 变量容易在不被察觉的情况下被覆盖掉

  ```js
  var myname = 'wwj';
  function showName(){
  	console.log(myname);//undefined
  	if(0) {
  		var myname = 'ww'; 
  	}
  	console.log(myname);//undefined
  }
  showName();
  ```

  

* 本应该销毁的变量没有被销毁

  ```js
  function foo(){
  	for(var i = 0; i < 7; i++) {
  	}
  	console.log(i);
  }
  ```

## ES6是如何解决变量提升带来的缺陷

为了解决变量提升带来的一系列问题，**ES6引入了let和const关键词**，从而使JavaScript也能像其他语言一样拥有了块级作用域。

let和const都可以生成块级作用域，区别是使用let关键词声明的变量是可以被改变的，而使用const声明的变量其值是不可以被改变的。

## JavaScript是如何支持块级作用域的

目前的ES6既要做到支持变量提升的特性，又要支持块级作用域，实现过程如下：

```js
function foo(){
	var a = 1;
	let b = 2;
	{
		let b = 3;
		var c = 4;
		let d = 5;
		console.log(a);
		console.log(b);
	}
	console.log(b);
	console.log(c);
	console.lgo(d);
}
foo();
```

当执行上面这段代码的时候，JavaScript引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，上面是ES5的时候，但是现在在ES6中，我们引入了let关键词，let关键词会创建块级作用域，那么let关键字是如何影响执行上下文的呢？

* **第一步是编译并创建执行上下文**
  * 函数内部通过var声明的变量，在编译阶段全都被存放到**变量环境**里面了
  * 通过let声明的变量，在编译阶段会被存放到**词法环境**中
  * 在函数的作用域内部，通过let 声明的变量并没有被存放到词法环境中

* **第二步继续执行代码**
  * 当执行到代码块里面时，变量环境中的a已经被设置成了1，词法环境中b的值已经被设置成了2
  * 当进入作用域块后，就会把该作用域块内部的变量(b,d)压到栈顶
  * 当执行到作用域块中console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量a的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查到了，就直接返回给JavaScript引擎，如果没有找到，那么继续在变量环境中查找。
  * 作用域执行完成后，b与d从词法环境内部的栈弹出



**其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当该作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构（这里指的是let或者const声明的变量）**
